<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Recursion</title>
  
  <subtitle>I&#39;m sorry, but what your opinion means very little to me.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-16T10:45:52.142Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiaochen Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CNN</title>
    <link href="http://yoursite.com/2019/02/15/CNN/"/>
    <id>http://yoursite.com/2019/02/15/CNN/</id>
    <published>2019-02-15T09:11:43.000Z</published>
    <updated>2019-02-16T10:45:52.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h2><p>从理论上，增加网络的层数，使网络更加复杂能够提取更加复杂的特征。但是通过实验发现，当网络层数增加时，网络准确度出现饱和甚至下降。56层的网络效果比20层的网络差。这是因为深层网络存在梯度消失或者梯度爆炸的问题。使得深度网络难以训练。</p><p><img src="/images/DL/CNN/deep_low.jpg" alt=""></p><h3 id="残差学习"><a href="#残差学习" class="headerlink" title="残差学习"></a>残差学习</h3><p>从极端情况考虑，在浅层的网络上加入恒等变换层，可以得到和浅层网络相同的效果。因此可以在这个基础上加入残差，降低学习复杂度。从直观上看残差学习需要学习的内容少，因为残差一般会比较小，学习难度小点。</p><h2 id="BatchNorm"><a href="#BatchNorm" class="headerlink" title="BatchNorm"></a>BatchNorm</h2><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>关于深度神经网络出现梯度消失和梯度爆炸的问题，要从BP算法上看。一个简单的神经网络绘制成下图所示。<br><img src="/images/DL/CNN/three_layer_nn.png" alt=""></p><p>神经网络公式表示如下：</p><script type="math/tex; mode=display">f_i = \sigma(f_{i-1}*W_i+b_i)</script><p>其中$f_i, W_i, b_i$分别代表第$i$层的输出，系数和偏置项。使用$f_0$表示输入x。$\sigma$代表sigmod函数。</p><p>BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整。参数更新策略为$w=w+\Delta w$，其中$\Delta w=-\alpha \frac{\partial loss}{\partial w}$</p><p>以$b_2$的反向梯度传播为例，<script type="math/tex">\Delta b_2=\frac{\partial loss}{\partial b_2}=\frac{\partial loss}{\partial f_4}\frac{\partial f_4}{\partial f_3}\frac{\partial f_3}{\partial f_2}\frac{\partial f_2}{\partial b_2}</script></p><p>其中每一层的反向梯度都是对激活函数的求导之后乘上$W_i$。</p><p><strong>梯度消失问题</strong><br>如果每一层的激活函数求导的值都小于1，那么经过很多层之后，浅层的梯度就接近于0。此时浅层得不到有效的训练，因此增加了层数未必效果就好。一般w初始化在0-1之间，所以总的乘积小于1。</p><p>Nielsen在《Neural Networks and Deep Learning》中的实验结果如下图，可以看出越浅的层训练的速度越慢，越深的层训练速度越快。第一层的速度比第四层慢了100倍。</p><p><img src="/images/DL/CNN/speed_bp.png" alt=""></p><p>第二，不同的激活函数对于梯度消失的影响不同。例如sigmod函数，如下图所示，$\sigma(x)=\frac{1}{1+e^{-x}}$的导数为$\sigma^{\prime}=\sigma*(1-\sigma)$。而sigmod函数的取值范围是(0, 1)，因此sigmod函数导数的取值最大为0.25。当神经网络层数增加之后，梯度消失的很快。</p><p><img src="/images/DL/CNN/sigmod.jpg" alt=""></p><p><strong>梯度爆炸问题</strong><br>如果每一层激活函数求导的值都大于1，那么经过很多层之后，浅层的梯度就是个很大的数字，浅层也同样的不到有效的训练。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;残差网络&quot;&gt;&lt;a href=&quot;#残差网络&quot; class=&quot;headerlink&quot; title=&quot;残差网络&quot;&gt;&lt;/a&gt;残差网络&lt;/h2&gt;&lt;p&gt;从理论上，增加网络的层数，使网络更加复杂能够提取更加复杂的特征。但是通过实验发现，当网络层数增加时，网络准确度出现饱和甚至下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列模型</title>
    <link href="http://yoursite.com/2019/02/01/%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/01/序列模型/</id>
    <published>2019-02-01T11:54:36.000Z</published>
    <updated>2019-02-12T10:14:16.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>其他网络只能接受固定长度的输入，并且输出固定长度的向量。</p><p>RNN有以下几种模式</p><p><img src="/images/DL/序列模型/1.four-type-rnn.jpeg" alt=""></p><ol><li>第一张图片就是非序列的神经网络，例如CNN。</li><li>第二张图片输入不是序列，输出是一个序列，例如：看图说话。</li><li>第三张图片输入是一个序列，输出是一个值，例如：文本分类。</li><li>第四张图片输入是一个序列，输出也是一个序列，但不是同步的。例如：机器翻译。</li><li>第五张图片输入是一个序列，输出也是一个序列，并且是同步的。例如：视频分类，每一帧一个分类。</li></ol><p>BPTT</p><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h3 id="基础LSTM和GRU"><a href="#基础LSTM和GRU" class="headerlink" title="基础LSTM和GRU"></a>基础LSTM和GRU</h3><h3 id="BI-LSTM"><a href="#BI-LSTM" class="headerlink" title="BI-LSTM"></a>BI-LSTM</h3><h3 id="ConvLSTM"><a href="#ConvLSTM" class="headerlink" title="ConvLSTM"></a>ConvLSTM</h3><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>Attention is all you need.</p><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Bert</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>推荐：xiangnan he. </li><li>轨迹预测</li><li>NLP：语音，语言模型，翻译，图片标题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RNN&quot;&gt;&lt;a href=&quot;#RNN&quot; class=&quot;headerlink&quot; title=&quot;RNN&quot;&gt;&lt;/a&gt;RNN&lt;/h2&gt;&lt;p&gt;其他网络只能接受固定长度的输入，并且输出固定长度的向量。&lt;/p&gt;
&lt;p&gt;RNN有以下几种模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编程可读代码的艺术》读书笔记</title>
    <link href="http://yoursite.com/2019/01/29/%E3%80%8A%E7%BC%96%E7%A8%8B%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/29/《编程可读代码的艺术》读书笔记/</id>
    <published>2019-01-29T06:19:06.000Z</published>
    <updated>2019-01-30T09:50:37.594Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习如何重构代码，在此记录一些重构代码的技术和方法。</p><p><strong>代码应当易于理解，代码的写法应当使别人理解它所需的时间最小化。</strong></p><h1 id="表面层次的改进"><a href="#表面层次的改进" class="headerlink" title="表面层次的改进"></a>表面层次的改进</h1><p>选择更好的名字，写好的注释，整洁的代码格式</p><h2 id="把信息装进名字里"><a href="#把信息装进名字里" class="headerlink" title="把信息装进名字里"></a>把信息装进名字里</h2><ol><li>选择专业的词，可以使用同义词词典。</li></ol><div class="table-container"><table><thead><tr><th>单词</th><th>更多选择</th></tr></thead><tbody><tr><td>send</td><td>deliver, dispatch, announce, distribute, route</td></tr><tr><td>find</td><td>search, extract, locate, recover</td></tr><tr><td>start</td><td>launch, create, begin, open</td></tr><tr><td>make</td><td>create, set up, build, generate, compose, add, new</td></tr></tbody></table></div><ol><li>避免使用tmp，retval这样泛泛的名字。<br>除非有好的理由，除了用在变量值交换的时候，其他时候最好用变量的具体含义起名字。在多层嵌套的for循环中，使用前缀比直接使用i, j, k能有效的防止出错。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; clubs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; clubs[i].members.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; users.size(); ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clubs[i].members[k] == users[j]) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码index多了容易出错，把member和users的index弄混了。</span></span><br><span class="line"><span class="comment">// 使用前缀的写法如下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ci=<span class="number">0</span>; ci &lt; clubs.size(); ++ci) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mi=<span class="number">0</span>; mi &lt; clubs[ci].members.size(); ++mi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ui=<span class="number">0</span>; ui &lt; users.size(); ++ui) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clubs[ci].members[mi] == users[ui]) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>用具体的名字代替抽象的名字<br>例如：—run_locally，目的是使用本地的数据库，应该改为—use_local_database</p></li><li><p>为名字附带更多信息<br>有关变量的重要信息可以加入变量名中。例如string id存储的是16进制的ID，那么可以改名为hex_id。</p></li><li><p>带单位的值<br>如果变量是一个度量的话，最好把名字带上单位。例如变量尾部追加ms代表毫秒。</p></li><li><p>变量的长度<br>作用域小的标识符可以使用短的名字，作用域大的标识符名字要包含更多的信息。</p></li><li><p>首字母缩略词和缩写<br>如果缩写不能让新成员看懂，那么就不要用缩写。常见的有string -&gt; str。</p></li><li><p>丢掉没有用的单词<br>例如ConverToString可以改为ToString。</p></li></ol><h2 id="使用不会误解的名字"><a href="#使用不会误解的名字" class="headerlink" title="使用不会误解的名字"></a>使用不会误解的名字</h2><p>有些名字会被理解成其他的含义，例如：BIG_LIMIT=10，可以理解成&lt;10，也可以理解成&lt;=10。容易带来歧义。</p><ol><li><p>使用min，max来表示包含的极限。在要限制的东西前面加上max<em>或者min</em>。</p></li><li><p>使用first，last来表示包含的范围。<br><img src="/images/code/chap3-first-last.png" alt=""></p></li><li><p>使用begin，end来表示包含/排除的范围。<br><img src="/images/code/chap3-begin-end.png" alt=""></p></li><li><p>对于bool值，前面加上is，has，can，should这样的词可以把bool值变得更加明确。不要使用反义名字，名字表示肯定意思。例如：不要使用bool disable_ssl=false，使用bool use_ssl=false。</p></li><li><p>使用与含义相匹配的名字。例如：对于get函数，期望的复杂度是O(1)，如果复杂的是O(n)则会影响使用。</p></li></ol><h2 id="审美"><a href="#审美" class="headerlink" title="审美"></a>审美</h2><p>三条基本原则：</p><ul><li>使用一致的布局，让读者很快就习惯这种风格。</li><li>让相似的代码看上去相似。</li><li>把相关的代码行分组，形成代码块。</li></ul><ol><li>重新安排换行来保持一致和紧凑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PerformanceTest &#123;</span><br><span class="line">    public static final TcpConnectionSimulator wifi = </span><br><span class="line">        new TcpConnectionSimulator(</span><br><span class="line">            500,   /* Kbps */</span><br><span class="line">            80,    /* millisecs latency */</span><br><span class="line">            200,   /* jitter */</span><br><span class="line">            1      /* packet loss % */</span><br><span class="line">        );</span><br><span class="line">    public static final TcpConnectionSimulator t3_fiber = </span><br><span class="line">        new TcpConnectionSimulator(</span><br><span class="line">            45000, /* Kbps */</span><br><span class="line">            80,    /* millisecs latency */</span><br><span class="line">            200,   /* jitter */</span><br><span class="line">            10     /* packet loss % */</span><br><span class="line">        );</span><br><span class="line">    public static final TcpConnectionSimulator cell = </span><br><span class="line">        new TcpConnectionSimulator(</span><br><span class="line">            100,  /* Kbps */</span><br><span class="line">            80,   /* millisecs latency */</span><br><span class="line">            1     /* packet loss % */</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把注释复制了三遍，占用了过多的纵向空间。通过下面的写法可以写的更加紧凑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PerformanceTest &#123;</span><br><span class="line">    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)</span><br><span class="line">    //                            [Kbps]     [ms]    [ms]    [percent]</span><br><span class="line">    public static final TcpConnectionSimulator wifi = </span><br><span class="line">        new TcpConnectionSimulator(500, 80, 200, 1);</span><br><span class="line">    public static final TcpConnectionSimulator t3_fiber = </span><br><span class="line">        new TcpConnectionSimulator(45000, 10, 0, 0);</span><br><span class="line">    public static final TcpConnectionSimulator cell = </span><br><span class="line">        new TcpConnectionSimulator(100, 400, 250, 5);</span><br></pre></td></tr></table></figure><ol><li><p>把声明按块组织起来，例如：构造函数，析构函数放在一起，request，post方法放在一起。</p></li><li><p>把代码分成段落，用空行按逻辑分隔，并写法一致。</p></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li>好的代码自带解释性，起好的函数名能够自己解释清楚。</li><li>记录思想，例如：注释教会读者一些东西，防止做无谓的优化。解释代码为什么写的不整洁。</li><li>加入TODO，FIXME等标签来记录代码的瑕疵。</li><li>给常量加注释，解释常量可以告诉读者为什么这么用。例如：0.72是经过尝试的最好的参数。</li><li>站在读者的角度，把读者想要提问的地方加上注释。</li></ol><p>什么地方不需要注释：能够代码本身推断的事实；用来粉饰烂代码的拐杖。</p><p>应该记录的想法包括：对于代码为什么写成这样而不是那样的理由；代码中的缺陷；常量背后的故事，为什么是这个值。</p><p>站在读者的立场上思考：预料到读者的问题；为意料之外的代码加上注释；在文件/类级别上使用“全局观”注释来解释所有部分是如何一起工作的；用注释来总结代码块，是的这不要迷失在细节上。</p><h2 id="写出言简意赅的注释"><a href="#写出言简意赅的注释" class="headerlink" title="写出言简意赅的注释"></a>写出言简意赅的注释</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习如何重构代码，在此记录一些重构代码的技术和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码应当易于理解，代码的写法应当使别人理解它所需的时间最小化。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;表面层次的改进&quot;&gt;&lt;a href=&quot;#表面层次的改进&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据可视化</title>
    <link href="http://yoursite.com/2019/01/26/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/26/数据可视化/</id>
    <published>2019-01-26T08:47:16.000Z</published>
    <updated>2019-01-26T10:44:48.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>可视化工具有如下几种，seaborn可以看作对matplotlib的高级封装；Plotly可以制作可交互的图片；Bokeh同样也是制作可交互的图片；ggplot是R包ggplot2的python版本，绘制静态图片；Graph visualization with NetworkX用于绘制图数据结构的包。</p><h2 id="类别变量可视化"><a href="#类别变量可视化" class="headerlink" title="类别变量可视化"></a>类别变量可视化</h2><p>类别变量可视化使用seaborn的catplot函数，可以绘制类别的散点图(stripplot, swarmplot)，类别分布图(boxplot, violinplot, boxenplot)，类别估计图(pointplot, barplot, countplot)</p><h3 id="stripplot"><a href="#stripplot" class="headerlink" title="stripplot"></a>stripplot</h3><p>catplot kind参数的默认值就是stripplot<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  total_bill   tip     sex smoker  day    time  size</span></span><br><span class="line"><span class="string">0       16.99  1.01  Female     No  Sun  Dinner     2</span></span><br><span class="line"><span class="string">1       10.34  1.66    Male     No  Sun  Dinner     3</span></span><br><span class="line"><span class="string">2       21.01  3.50    Male     No  Sun  Dinner     3</span></span><br><span class="line"><span class="string">3       23.68  3.31    Male     No  Sun  Dinner     2</span></span><br><span class="line"><span class="string">4       24.59  3.61  Female     No  Sun  Dinner     4</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, data=tips);</span><br></pre></td></tr></table></figure></p><p><img src="https://seaborn.pydata.org/_images/categorical_4_0.png" alt=""><br>使用jitter参数控制每个类别的宽度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, jitter=<span class="keyword">False</span>, data=tips);</span><br></pre></td></tr></table></figure><p><img src="https://seaborn.pydata.org/_images/categorical_6_0.png" alt=""></p><h3 id="swarmplot"><a href="#swarmplot" class="headerlink" title="swarmplot"></a>swarmplot</h3><p>swarmplot把数据按树形展开，防止重叠，并体现出了数据的分布。类似于琴图。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, hue=<span class="string">"sex"</span>, kind=<span class="string">"swarm"</span>, data=tips);</span><br></pre></td></tr></table></figure></p><p><img src="https://seaborn.pydata.org/_images/categorical_10_0.png" alt=""></p><p>使用order参数，传入一个list，可以控制类别的先后顺序。</p><h3 id="boxplot"><a href="#boxplot" class="headerlink" title="boxplot"></a>boxplot</h3><p>关于箱型图，箱型图包括中位数，上四分位数，下四分位数，上限，下限，异常点。分位距IQR=Q3-Q1，异常值是大于Q3+1.5IQR或者小于Q1-1.5IQR范围内的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"day"</span>, y=<span class="string">"total_bill"</span>, kind=<span class="string">"box"</span>, data=tips);</span><br></pre></td></tr></table></figure></p><p><img src="https://seaborn.pydata.org/_images/categorical_18_0.png" alt=""></p><h3 id="boxenplot"><a href="#boxenplot" class="headerlink" title="boxenplot"></a>boxenplot</h3><p>相对于boxplot，boxenplot展示了更多的信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diamonds = sns.load_dataset(<span class="string">"diamonds"</span>)</span><br><span class="line">sns.catplot(x=<span class="string">"color"</span>, y=<span class="string">"price"</span>, kind=<span class="string">"boxen"</span>,</span><br><span class="line">            data=diamonds.sort_values(<span class="string">"color"</span>));</span><br></pre></td></tr></table></figure></p><p><img src="https://seaborn.pydata.org/_images/categorical_24_0.png" alt=""></p><h3 id="violinplot"><a href="#violinplot" class="headerlink" title="violinplot"></a>violinplot</h3><p>琴图结合了箱型图和核密度估计<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"day"</span>, hue=<span class="string">"time"</span>,</span><br><span class="line">            kind=<span class="string">"violin"</span>, data=tips);</span><br></pre></td></tr></table></figure></p><p><img src="https://seaborn.pydata.org/_images/categorical_26_0.png" alt=""></p><h3 id="barplot"><a href="#barplot" class="headerlink" title="barplot"></a>barplot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic = sns.load_dataset(<span class="string">"titanic"</span>)</span><br><span class="line">sns.catplot(x=<span class="string">"sex"</span>, y=<span class="string">"survived"</span>, hue=<span class="string">"class"</span>, kind=<span class="string">"bar"</span>, data=titanic);</span><br></pre></td></tr></table></figure><p><img src="https://seaborn.pydata.org/_images/categorical_36_0.png" alt=""></p><h3 id="pointplot"><a href="#pointplot" class="headerlink" title="pointplot"></a>pointplot</h3><p>pointplot 在barplot的基础上比较了不同类之间的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"sex"</span>, y=<span class="string">"survived"</span>, hue=<span class="string">"class"</span>, kind=<span class="string">"point"</span>, data=titanic);</span><br></pre></td></tr></table></figure><p><img src="https://seaborn.pydata.org/_images/categorical_42_0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可视化工具&quot;&gt;&lt;a href=&quot;#可视化工具&quot; class=&quot;headerlink&quot; title=&quot;可视化工具&quot;&gt;&lt;/a&gt;可视化工具&lt;/h2&gt;&lt;p&gt;可视化工具有如下几种，seaborn可以看作对matplotlib的高级封装；Plotly可以制作可交互的图片；Bo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据预处理</title>
    <link href="http://yoursite.com/2019/01/20/feature-preprocess/"/>
    <id>http://yoursite.com/2019/01/20/feature-preprocess/</id>
    <published>2019-01-20T11:02:02.000Z</published>
    <updated>2019-01-26T12:17:04.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据预处理流程"><a href="#数据预处理流程" class="headerlink" title="数据预处理流程"></a>数据预处理流程</h2><ol><li>判断数据类型，判断每一列数据的类型，float，category，boolean，text。</li><li>删除只有一个值的特征。</li><li>删除相同的特征，有些特征虽然值不一样，但只是用了不同的代号而已。</li><li>根据特征的类型产生新的特征。例如，对于连续的特征，每个月的销量的累加，对于神经网络，可以自动产生这种特征，但是对于树模型，无法处理这种特征。对于类别的特征，参考下面类别特征。</li><li>可以加入近邻数据的特征的平均值作为新的特征，但是定义近邻距离时，首先要确定不同的特征组(可以根据特征的均值分类)，之后给定不同特征组不同的系数，然后求出距离。</li></ol><h2 id="Numeric-Feature"><a href="#Numeric-Feature" class="headerlink" title="Numeric Feature"></a>Numeric Feature</h2><p>对于线性模型需要Feature scaling，不同的scale会对梯度下降有很大的影响，scale大的feature的微小变动对结果影响很大。</p><ul><li>Scaling<ul><li>MinMaxScaler：不改变分布</li><li>StandardScaler</li></ul></li><li>Outliers<br>使用可视化的方法，发现outliers。<ul><li>Feature clipping: 使用99%的分位数作为最大的。</li><li>Rank：使用排序代替原始值，如果无法使用可视化发现outliers</li></ul></li><li>使数据变紧凑<ul><li>np.log(1+x), np.sqrt(1+x)</li></ul></li></ul><h2 id="Categorical-and-ordinal-features"><a href="#Categorical-and-ordinal-features" class="headerlink" title="Categorical and ordinal features"></a>Categorical and ordinal features</h2><p>categorical feature没有序，例如：性别。ordinal feature有序，例如：仓位，年级。</p><p>对于Tree，使用Label encoding或者Frequency encoding。<br>对于其他模型，使用One-hot necoding。不同的categorical feature或者ordinal feature之间可以做交互。例如：性别和仓位，变成1male, 2male, 1female, 2female。这样的做法对于线性模型有很大帮助。</p><h2 id="Datetime-and-coordinates-features"><a href="#Datetime-and-coordinates-features" class="headerlink" title="Datetime and coordinates features"></a>Datetime and coordinates features</h2><p>对于Datetime feature可以转换为，day of week, week of year, season of year；可以转换为距离某一个特定日期的距离，例如距离周末的距离；是否是节假日；</p><p>对于Coordinates feature可以转化为距离某一个点，可以是train set中的，也可以是额外的(地标，城市中心)的距离，转换为格子内的统计信息。</p><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>缺失值的类型有：NA，空字符串，-1，很大的数字，-99999，999，99。通过可视化的方式，可以找出缺失值。</p><p>可以使用mean或者median值填充，也可以使用拟合的方式填充。增加一列标记是否缺失的二值变量。</p><p>不要在产生新的feature之前对缺失值做填充，否则会影响产生的feature。</p><h2 id="文本特征"><a href="#文本特征" class="headerlink" title="文本特征"></a>文本特征</h2><p>文本预处理，在提取文本特征之前要对文本做预处理，预处理包括：(1)将文本变为小写，同样的单词大写和小写的意义是相同的。(2)提取词干，将名词，形容词转换为相同的词干。(3)Lemmatization，将名词，形容词都转换为名词形式，过去式转换为现在式。(4)去除停词。这一步可以使用sklearn.feature_extraction.text.CountVectorizer，其中参数max_df指去除出现次数多少次以上的单词。</p><p><strong>BOW</strong>提取特征，每个单词作为数据中的一个维度，使用sklearn.feature_extraction.text.CountVectorizer来完成这个工作，其中Ngram_range指定使用多少个gram, analyzer指定以单词为单位还是字母为单位。由于不同文本的长度不同，所以单词出现的频率也不同。需要使用tf-idf来衡量每个单词的重要性。</p><p>tf-idf原理，在一份给定的文件里，词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率。这个数字是对词数（term count）的归一化，以防止它偏向长的文件。tf可以表示为：</p><script type="math/tex; mode=display">\mathrm { tf } _ { \mathrm { i } , \mathrm { j } } = \frac { n _ { i , j } } { \sum _ { k } n _ { k , j } }</script><p>逆向文件频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到：</p><script type="math/tex; mode=display">\operatorname { idf } _ { \mathrm { i } } = \lg \frac { | D | } { \left| \left\{ j : t _ { i } \in d _ { j } \right\} \right| }</script><p>其中$|D|$：语料库中的文件总数<br>$ | {j : t<em> i \in d_j}| $包含词语$t_i$的文件数目（即 $n</em>{i,j} \neq 0$的文件数目）如果词语不在数据中，就导致分母为零，因此一般情况下使用 $1 + \left| \left{ j : t <em> { i } \in d </em> { j } \right} \right|$<br>然后</p><script type="math/tex; mode=display">\operatorname { tfidf } _ { \mathrm { i } , \mathrm { j } } = \mathrm { tf } _ { \mathrm { i } , \mathrm { j } } \times \mathrm { idf } _ { \mathrm { i } }</script><p>例子：假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3/100=0.03。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现“母牛”一词的文件数。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 / 1,000）=4。最后的tf-idf的分数为0.03 * 4=0.12。</p><p>如果只针对单词提取特征，疑问句和陈述句可能得到相同的结果。例如：’This is the first document.’ 和 ‘Is this the first document?’。为了防止词组顺序颠倒，除了提取一元模型 1-grams（个别词）之外，我们还可以提取 2-grams 的单词。</p><p><strong>Word2Vec</strong>，</p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>可视化可以帮助我们发现有用的feature，并且使用他们产生新的feature。通常来说，没有特定的一套方法能够对所有的数据可视化。需要不断的输出数据，绘制数据，发现有用的数据之后进行进一步的探索。</p><p>数据可视化有以下方法：</p><ul><li>Histograms，绘制直方图可以看出数据的分布。但是直方图有时候可能会带来错觉。如下图，左边的直方图看来，所有数据都是0。对数据取log(1+x)之后可以发现，数据有很多不同的值。尖峰的原因可能是很多缺失值被用平均值或者中位数填充了。<br><img src="/images/ML/feature_preprocess/eda_hist.png" alt=""></li></ul><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>在机器学习算法的目标函数(例如SVM的RBF内核或线性模型的l1和l2正则化)，许多学习算法中目标函数的基础都是假设所有的特征都是零均值并且具有同一阶数上的方差。如果某个特征的方差比其他特征大几个数量级，那么它就会在学习算法中占据主导位置，导致学习器并不能像我们说期望的那样，从其他特征中学习。</p><p>标准化能够加速梯度下降，如下图：<br><img src="/images/ML/feature_preprocess/sgd.jpeg" alt=""><br>左边蓝色的图片，由于$x_2$的范围比较大，因此$w_2$的微小变化损失函数就有很大的变化。反之$w_1$要变化很多损失函数才有明显变化。从梯度下降的公式来说，$w_1$的变化取决于$x_1$，因此梯度很小，那么需要很久才能下降到最低点。右边的图片做了标准化，能够很快的下降到最低点。</p><h2 id="其他变换"><a href="#其他变换" class="headerlink" title="其他变换"></a>其他变换</h2><p>QuantileTransformer把数据变成对应的分为数，例如原本处于0.25分位数的数字是6.8，变化之后就是0.25。这个变换是一个非线性变换。</p><p>归一化，是 缩放单个样本以具有单位范数的过程。</p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p><strong>清洗常量的数据</strong>，常量的数据对于分类没有帮助，需要去除掉。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `dropna = False` makes nunique treat NaNs as a distinct value</span></span><br><span class="line">feats_counts = train.nunique(dropna = <span class="keyword">False</span>)</span><br><span class="line">feats_counts.sort_values()[:<span class="number">10</span>]</span><br><span class="line">constant_features = feats_counts.loc[feats_counts==<span class="number">1</span>].index.tolist()</span><br><span class="line"><span class="keyword">print</span> (constant_features)</span><br><span class="line"></span><br><span class="line">traintest.drop(constant_features,axis = <span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p><strong>清洗重复的数据</strong>，对于不同的列，可能使用符号不同，但是本质是相同的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">train_enc =  pd.DataFrame(index = train.index)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> tqdm_notebook(traintest.columns):</span><br><span class="line">    train_enc[col] = train[col].factorize()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">dup_cols = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, c1 <span class="keyword">in</span> enumerate(tqdm_notebook(train_enc.columns)):</span><br><span class="line">    <span class="keyword">for</span> c2 <span class="keyword">in</span> train_enc.columns[i + <span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> c2 <span class="keyword">not</span> <span class="keyword">in</span> dup_cols <span class="keyword">and</span> np.all(train_enc[c1] == train_enc[c2]):</span><br><span class="line">            dup_cols[c2] = c1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line">pickle.dump(dup_cols, open(<span class="string">'dup_cols.p'</span>, <span class="string">'w'</span>), protocol=pickle.HIGHEST_PROTOCOL)</span><br><span class="line"></span><br><span class="line">traintest.drop(dup_cols.keys(), axis = <span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据预处理流程&quot;&gt;&lt;a href=&quot;#数据预处理流程&quot; class=&quot;headerlink&quot; title=&quot;数据预处理流程&quot;&gt;&lt;/a&gt;数据预处理流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;判断数据类型，判断每一列数据的类型，float，category，boolean，tex
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="数据处理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>张江895孵化器访问</title>
    <link href="http://yoursite.com/2019/01/16/%E5%BC%A0%E6%B1%9F895%E5%AD%B5%E5%8C%96%E5%99%A8%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2019/01/16/张江895孵化器访问/</id>
    <published>2019-01-16T13:44:19.000Z</published>
    <updated>2019-01-16T14:50:58.033Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/life/895incubator.jpg" alt=""></p><p>由于寒假社会生活实践的原因，今天我拜访了位于张江高科的895医疗健康孵化器。这家公司成立于2013年，于2017年12月正式开始运营孵化器，大部分的公司处在A轮之前，产品处于生产出来之前。目前有8家孵化企业，追求小而精的团队。其中设计AI的有3家，大部分是医疗器械和智慧养老。这家孵化器属于民营公司，主要通过已有的创业经验来帮助创业团队，帮助走过创业的初期。对比学校的孵化器所做的产品更加深入，对比政府的孵化器，能够在应用和技术的细节上为创业团队提供帮助，而不只是政策引导的帮助(政府的孵化器相当于是老教授，民营孵化器相当于是高年级学长)。管理团队来自各个创业团队的主要成员。895医疗健康孵化器对于挑选入住孵化器的团队主要看3个方面，(1)技术创新性，临床需求；(2)公司的成熟度是否和孵化器匹配；(3)和已经入住的团队是否匹配。</p><p>这是我第一次了解什么是孵化器，孵化器有什么作用，以及人工智能在医疗领域的应用现状。</p><p>一般来讲，创业开始都是有了一个不错的idea或者是有了一项创新的技术。但是创立一个公司却不单单是这些。创始人要考虑出了技术之外的很多方面，例如：财务，法务，客户等等问题。一个没有经验的创业者，会被这些问题阻碍。因此针对出了技术之外的繁杂问题，孵化器主要从以下三个方面提供了帮助，(1)软硬件设施；(2)行业资源；(3)生态圈。</p><p><strong>软硬件设施</strong>。首先是孵化器为创业团队提供了办公场所，但这是最不重要的一点。如果只是办公场所，孵化器和二房东就没有区别了。例如：一个团队做出来算法的创新，需要做一款APP来推向市场。传统的方式是自己聘用做APP的人，或者外包出去。前者由于开发不是重点，如果没有足够的资金，那么难以保证质量，而且一时间也难以组建一个合适的开发团队。后者外包的开发的团队一般对于创业的领域了解程度不够，在对接需求上会花费大量的经历，也会影响产品的质量(这一点我深有体会，在2018年11月上线一个产品时，由于开发团队没有金融的基础，每次新来一个业务人员，我需要把整个背景讲一遍，处理问题的细节时也经常出错)。孵化器里面的企业类型相同或者相似，直接配以开发团队，轮流为各个创业团队提供开发服务，既为开发团队解决了不必要的问题，又深入了业务，减少了大量的错误，节省了成本。除此之外，一个产品开发出来，后期的跟踪很重要。但是创业团队不一定有专业的专门的人负责这件事情。例如：监测老人身体状况的手环，孵化器配备的人员会定期回访手环使用情况。检测到老人摔倒，到底是真的摔倒，还是老人在做什么事情。医疗数据有数据量小，但是要求准确性高的特点。通过后期跟踪，能够及时的得到数据反馈，调整模型。第三，平台能够让产品尽快实践，得到实际的反馈，产品操作是否便捷，培训是否简单。这些决定了最终是否有人买账。以上的软硬件设施或者团队，在创业初期很难建设完全。但是这些模块缺一不可，孵化器就成了一个很好的支持。</p><p><strong>行业资源</strong>。医疗器械的成熟慢，一个产品要5-8年的周期，过程中要设计方方面面。因此把一个想法或者一个算法变成产品，行业资源是不可缺少的。在医疗行业，国家有非常严格的监管。对于每一个产品如何验证其安全性，如何设计临床实验，如何保证生产中的质量。这些大坑足以把绝大部分创业者卡死，毕竟医疗行业产品要保证最差的时候也要有很高的准确率。一次错误也不能犯。孵化器在这些方面有丰富的资源，能够及时的为创业团队提供这些服务。</p><p><strong>生态圈</strong>。孵化器中同时存在相同类型的多家公司，是一个很好的生态圈，不同公司之间往往会擦出不可思议的火花。例如：一个做医疗穿戴的团队和智慧社区养老的团队合作，同时解决了两个团队的问题。在一个大的平台上能够拓宽思路和产品的销路。</p><p>总体来说，医疗行业和互联网行业还是有很大的区别。医疗行业的成熟速度慢，很保守，产品要有严格的安全性。尽管目前有很多论文，但是产品的下限还难以保证，因此人工智能在医疗领域的应用还有很大的发展空间。</p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/life/895incubator.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于寒假社会生活实践的原因，今天我拜访了位于张江高科的895医疗健康孵化器。这家公司成立于2013年，于2017年12月正式开始运营孵化器，大部分的公司处在A轮之
      
    
    </summary>
    
      <category term="生活游记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="生活游记" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GANs</title>
    <link href="http://yoursite.com/2019/01/14/GANs/"/>
    <id>http://yoursite.com/2019/01/14/GANs/</id>
    <published>2019-01-14T13:41:49.000Z</published>
    <updated>2019-01-14T13:46:23.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对抗生成网络笔记"><a href="#对抗生成网络笔记" class="headerlink" title="对抗生成网络笔记"></a>对抗生成网络笔记</h1><p>这篇文章用来记录各种GAN的原理和应用。</p><h2 id="EBGAN-ENERGY-BASED-GENERATIVE-ADVERSARIAL-NETWORKS"><a href="#EBGAN-ENERGY-BASED-GENERATIVE-ADVERSARIAL-NETWORKS" class="headerlink" title="EBGAN(ENERGY-BASED GENERATIVE ADVERSARIAL NETWORKS)"></a>EBGAN(ENERGY-BASED GENERATIVE ADVERSARIAL NETWORKS)</h2><p>作者：Junbo Zhao, Michael Mathieu and Yann LeCun<br>发表：ICLR 2017</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对抗生成网络笔记&quot;&gt;&lt;a href=&quot;#对抗生成网络笔记&quot; class=&quot;headerlink&quot; title=&quot;对抗生成网络笔记&quot;&gt;&lt;/a&gt;对抗生成网络笔记&lt;/h1&gt;&lt;p&gt;这篇文章用来记录各种GAN的原理和应用。&lt;/p&gt;
&lt;h2 id=&quot;EBGAN-ENERGY-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>集成学习</title>
    <link href="http://yoursite.com/2019/01/05/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/05/集成学习/</id>
    <published>2019-01-05T05:19:25.000Z</published>
    <updated>2019-01-05T09:46:53.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;随机森林&quot;&gt;&lt;a href=&quot;#随机森林&quot; class=&quot;headerlink&quot; title=&quot;随机森林&quot;&gt;&lt;/a&gt;随机森林&lt;/h2&gt;
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="Ensemble Learning" scheme="http://yoursite.com/tags/Ensemble-Learning/"/>
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yoursite.com/2019/01/05/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2019/01/05/决策树/</id>
    <published>2019-01-05T04:02:20.000Z</published>
    <updated>2019-02-15T09:16:39.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策树优点"><a href="#决策树优点" class="headerlink" title="决策树优点"></a>决策树优点</h2><ol><li>容易解释，可以可视化。</li><li>对数据预处理的要求低，不需要做数据归一化，允许数据有缺失。</li><li>可以处理连续型变量和离散型变量。</li></ol><h2 id="决策树的缺点"><a href="#决策树的缺点" class="headerlink" title="决策树的缺点"></a>决策树的缺点</h2><ol><li>容易过拟合，可以通过剪枝，设置每个节点最小样本数量，树的最大深度来避免。</li><li>容易收到干扰，某些数据的微小变化可能带来树的巨大变化。其实就是方差的问题，减小方差可以通过ensemble的方式缓解。</li><li>无法保证找到最优的树，找到最优的树是一个NPC问题。因此，每个节点分裂时，使用贪心算法。只能得到局部最优解。可以通过ensemble的方式缓解，训练每棵树时对数据和特征做采样。</li><li>There are concepts that are hard to learn because decision trees do not express them easily, such as XOR, parity or multiplexer problems.</li><li>对于数据不平衡问题，树可能有很大的偏差，需要先解决数据不平衡问题。</li></ol><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ol><li>数据量和特征数量要匹配，数据很少，但是特征很多很容易过拟合。</li><li>提前使用PCA，ICA或者Feature Selection降维可以让树学的更好。</li><li>事先解决数据不平衡问题。例如通过采样方式，或者通过normalizing the sum of the sample weights for each class的方式实现。</li></ol><h2 id="不同类型的树"><a href="#不同类型的树" class="headerlink" title="不同类型的树"></a>不同类型的树</h2><h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><p>ID3树每个节点有多个分支，根据信息增益来作为分裂标准。在树生成之后使用剪枝来防止过拟合。</p><p>缺点：只能使用离散特征，只能针对分类问题。</p><p>信息熵，表示数据的不确定程度。公式如下：</p><script type="math/tex; mode=display">entropy=\sum _ { x \in X } - p ( x ) \log _ { 2 } p ( x )</script><p>信息增益，公式如下：</p><script type="math/tex; mode=display">I G ( S , A ) = \mathrm { H } ( S ) - \sum _ { t \in T } p ( t ) \mathrm { H } ( t )</script><p>ID3算法：</p><ol><li>遍历所有特征，找到IG最大的特征。</li><li>使用该特征进行划分。并删除该特征。</li><li>循环1-2，直到所有数据为相同类别，或者达到叶子节点最小数量要求。</li></ol><h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h3><p>C4.5树是ID3的一个后续，使用信息增益率作为分裂标准，可以使用连续值作为特征(对于一个连续特征，取所有数据中出现的值，排序之后，取相邻的两个值的均值作为划分点)。采用后剪枝防止过拟合。</p><p>缺点：只能针对分类问题。</p><h3 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h3><p>CART树支持回归问题，对于分类问题使用基尼系数的增益作为分裂标准。对于回归问题使用MSE作为分裂标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;决策树优点&quot;&gt;&lt;a href=&quot;#决策树优点&quot; class=&quot;headerlink&quot; title=&quot;决策树优点&quot;&gt;&lt;/a&gt;决策树优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;容易解释，可以可视化。&lt;/li&gt;
&lt;li&gt;对数据预处理的要求低，不需要做数据归一化，允许数据有缺失。&lt;/
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="tree" scheme="http://yoursite.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost结果分析</title>
    <link href="http://yoursite.com/2019/01/03/XGBoost%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/03/XGBoost结果分析/</id>
    <published>2019-01-03T09:11:38.000Z</published>
    <updated>2019-01-05T03:57:21.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用eli5进行解释"><a href="#使用eli5进行解释" class="headerlink" title="使用eli5进行解释"></a>使用eli5进行解释</h2><p>这里参考eli5的文档，使用kaggle泰坦尼克数据集为例，对XGBoost的结果进行解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用eli5进行解释&quot;&gt;&lt;a href=&quot;#使用eli5进行解释&quot; class=&quot;headerlink&quot; title=&quot;使用eli5进行解释&quot;&gt;&lt;/a&gt;使用eli5进行解释&lt;/h2&gt;&lt;p&gt;这里参考eli5的文档，使用kaggle泰坦尼克数据集为例，对XGBoo
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="xgboost" scheme="http://yoursite.com/tags/xgboost/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost使用</title>
    <link href="http://yoursite.com/2019/01/03/XGBoost%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/03/XGBoost使用/</id>
    <published>2019-01-03T08:40:30.000Z</published>
    <updated>2019-01-03T08:41:00.575Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="xgboost" scheme="http://yoursite.com/tags/xgboost/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost原理</title>
    <link href="http://yoursite.com/2019/01/01/XGBoost%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/01/XGBoost原理/</id>
    <published>2019-01-01T07:21:38.000Z</published>
    <updated>2019-01-03T08:38:15.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树可以分为3类，采用不同的分裂标准，(1)采用<strong>信息增益</strong>，ID3算法。(2)采用<strong>信息增益率</strong>，c4.5算法。(3)采用<strong>基尼指数</strong>CART树。</p><p><strong>CART树</strong></p><p>XGBoost使用CART(Classification And Regression Tree, 分类回归树)作为基分类器。</p><p>基尼指数公式：</p><script type="math/tex; mode=display">\operatorname { Gini } ( D ) = \sum _ { k = 1 } ^ { K } p _ { k } \left( 1 - p _ { k } \right)</script><p>基尼指数增益公式：</p><script type="math/tex; mode=display">\operatorname { Gini } ( D , A ) = \frac { \left| D _ { 1 } \right| } { | D | } \operatorname { Gini } \left( D _ { 1 } \right) + \frac { \left| D _ { 2 } \right| } { | D | } \operatorname { Gini } \left( D _ { 2 } \right)</script><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>目标函数，目标函数如下</p><script type="math/tex; mode=display">\operatorname { Obj } ( t ) = \sum _ { i = 1 } ^ { n } L \left( y _ { i } , \hat { y } ^ { t - 1 } + f _ { t } \left( x _ { i } \right) \right) + \Omega \left( f _ { t } \right) + \text { constant }</script><p>其中constant是一个常数，$\Omega \left( f _ { t } \right)$为正则项。</p><p>正则项如下：</p><script type="math/tex; mode=display">\Omega \left( f _ { t } \right) = \gamma T + \frac { 1 } { 2 } \lambda \sum _ { i = 1 } ^ { T } w _ { j } ^ { 2 }</script><p>优化目标函数是为了计算每个叶子节点的权重。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li>XGBoost比GradientBoost好的原因：<ol><li>增加正则项，树越复杂，惩罚越大，防止over-fitting, 而GB没有惩罚项。</li><li>在迭代更新的时候，XGBoost采用了二阶导数(海瑟矩阵)，而GB只用了一阶导数(梯度)。</li><li>XGBoost采用了并行计算，块处理，稀疏矩阵等技术。</li><li>节点分裂方式不同，gbdt使用gini指数，XGBoost是经过优化推导后的。</li></ol></li></ul><ul><li><p>XGBoost进化历程：</p><p>  <strong>决策树</strong> -&gt; 对样本重抽样，多棵树平均-&gt; <strong>Tree Bagging</strong> -&gt; 对特征进行随机挑选 -&gt; <strong>随机森林</strong> -&gt; 对随机森林中的树进行加权平均，而非简单平均 -&gt; <strong>Boosting</strong> -&gt; 对Boosting中的树进行正则化 -&gt; XGBoost</p></li></ul><p>对比模型：MART, DART(DART:Dropouts meet Multiple Additive Regression Trees), LightGBM, CatBoost</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;决策树&quot;&gt;&lt;a href=&quot;#决策树&quot; class=&quot;headerlink&quot; title=&quot;决策树&quot;&gt;&lt;/a&gt;决策树&lt;/h2&gt;&lt;p&gt;决策树可以分为3类，采用不同的分裂标准，(1)采用&lt;strong&gt;信息增益&lt;/strong&gt;，ID3算法。(2)采用&lt;strong&gt;
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
    
      <category term="xgboost" scheme="http://yoursite.com/tags/xgboost/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/01/01/hello-world/"/>
    <id>http://yoursite.com/2019/01/01/hello-world/</id>
    <published>2019-01-01T07:12:38.129Z</published>
    <updated>2019-01-01T07:12:38.129Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
